Object-Oriented Programming (OOP) is a way to write programs using classes (blueprints) and objects (real things created from classes). It makes coding simple, reusable, and well-organized.

It works on DRY (Don't Repeat Yourself) principle means you should avoid repeating the same code or logic in multiple places. Instead, write it once and reuse it.

Class: A class is a blueprint for creating objects, like a "Car" blueprint defining color and speed.
Object: An object is a real thing made from a class, like a "Red Car" with 100 km/h speed.

*******************************************

Syntax for Creating a Class in C++:
class ClassName {
public:
    // properties and methods go here
};

Syntax for Creating an Object in C++:
ClassName objectName;

Example:
#include <iostream>
using namespace std;

// Creating a class
class Car {
public:
    string color;
    int speed;

    void displayDetails() {
        cout << "Color: " << color << ", Speed: " << speed << " km/h" << endl;
    }
};

// Creating an object
int main() {
    Car myCar;          // Object created
    myCar.color = "Red";
    myCar.speed = 100;

    myCar.displayDetails(); // Output: Color: Red, Speed: 100 km/h
    return 0;
}

*******************************************

Inheritance means one class (child) can use the features (data and methods) of another class (parent). It's like a child getting traits from their parents.

Base Class: The class whose features (data and methods) are inherited by another class. It's like the parent class.
Derived Class: The class that inherits features from the base class. It's like the child class.

Single Inheritance: One child class inherits from one parent class.
Multilevel Inheritance: A child class inherits from a parent class, and another class inherits from that child class.
Hierarchical Inheritance: Multiple child classes inherit from one parent class.
Multiple Inheritance: A child class inherits from more than one parent class.
Hybrid Inheritance: A combination of two or more types of inheritance.

**************************************************

Encapsulation is the concept of hiding the internal details of an object and only showing the necessary parts. It keeps data safe by restricting direct access and allows controlled access through methods.

Encapsulation can be understood through a real-world example:

Imagine a TV remote. The remote has buttons (methods) like power on/off, volume up/down, and channel change. However, inside the remote, there are wires and circuit boards (data) that you cannot directly access. The remote encapsulates all the complex details inside and only exposes simple actions (methods) for you to interact with, like pressing buttons.

********************************************************
Abstraction is the concept of hiding complex details and showing only the necessary parts. It allows you to focus on what something does, not how it works.

Real-World Example:
Think of a car. When you drive a car, you just need to know how to use the steering wheel, accelerator, and brakes to control it. You don't need to understand how the engine or transmission works inside the car. The car abstracts away the complex details and lets you focus on driving.

In programming, abstraction works in a similar way by hiding unnecessary implementation details and exposing only the relevant features.

********************************************************

Polymorphism means the ability of one function or method to work in different ways depending on the object it is acting on. It lets you use the same name for different actions.

Types of Polymorphism:

Compile-time Polymorphism (Static Polymorphism):
This happens when the method or function is decided at compile time. The most common example is function overloading or operator overloading.
Example:
A function add() can work with two integers or two floats, but it's the same function 

Run-time Polymorphism (Dynamic Polymorphism):
This happens when the method or function is decided at runtime. It typically uses inheritance and function overriding.
Example:
A parent class Animal has a method sound(), but each child class (like Dog and Cat) makes a different sound:

********************************************************

Data binding is a way to connect the data in your application (like values or variables) to the user interface (UI), so when the data changes, the UI automatically updates to reflect the new values.

Simple Example:
Imagine a shopping cart on an e-commerce website. The total price shown on the screen is automatically updated whenever you add or remove an item from the cart. Data binding makes this automatic update happen without you having to manually change the price on the screen.

********************************************************

Method overloading is when you create multiple methods in the same class with the same name but different parameters (number or type). This allows you to perform similar actions with different inputs using the same method name.

Example:-

class Calculator {
public:
    // Method to add two integers
    int add(int a, int b) {
        return a + b;
    }
    
    // Method to add three integers (same name, different parameters)
    int add(int a, int b, int c) {
        return a + b + c;
    }
};

int main() {
    Calculator calc;
    cout << calc.add(2, 3);     // Calls the method with 2 parameters
    cout << calc.add(2, 3, 4);  // Calls the method with 3 parameters
}

********************************************************

A constructor is a special method in a class that is automatically called when an object is created. It initializes the object's properties.

Default Constructor: A constructor that takes no arguments and initializes the object with default values.

Parameterized Constructor: A constructor that takes arguments to initialize an object with specific values.

Copy Constructor: A constructor that creates a new object by copying an existing object.

********************************************************

A destructor is a special method in a class that is automatically called when an object is destroyed. It cleans up resources or memory that the object may have used during its lifetime. It has the same name as the class but with a tilde (~) before it.

Example:

class Car {
public:
    // Constructor
    Car() {
        cout << "Car created!" << endl;
    }

    // Destructor
    ~Car() {
        cout << "Car destroyed!" << endl;
    }
};

int main() {
    Car myCar;  // Constructor called
}  // Destructor called when myCar goes out of scope

********************************************************

this pointer in C++

The this pointer in C++ is a special pointer that points to the current object of the class. It is used to refer to the object that is calling the member function.

Key Points:
this is an implicit pointer passed to all non-static member functions.
It helps distinguish between member variables and parameters with the same name.
It can be used to access or modify the objectâ€™s data inside a member function.

Example:-

#include <iostream>
using namespace std;

class Car {
public:
    string color;

    // Constructor
    Car(string color) {
        this->color = color;  // 'this' differentiates between member variable and parameter
    }

    void display() {
        cout << "Car color is: " << this->color << endl; // Using 'this' to refer to the object
    }
};

int main() {
    Car myCar("Red");
    myCar.display();  // Output: Car color is: Red
}

********************************************************

A friend function in C++ is a function that is not a member of a class but can access its private and protected members. It is declared using the friend keyword inside the class.

#include <iostream>
using namespace std;

class Box {
private:
    int length;
public:
    Box(int l) : length(l) {}

    // Declaring the friend function
    friend void printLength(Box b);
};

// Friend function definition
void printLength(Box b) {
    cout << "Length: " << b.length << endl;  // Accesses private member of Box
}

int main() {
    Box box(10);
    printLength(box);  // Accesses private member using friend function
}

********************************************************

Aggregation is a type of relationship between classes where one class contains objects of another class. It represents a "has-a" relationship, meaning one class has another class as part of it, but both can exist independently.

********************************************************


A virtual function in C++ is a function in a base class that is meant to be overridden in a derived class. It allows dynamic (run-time) polymorphism, meaning the function called is determined by the type of the object pointed to, not the type of the pointer.

class Animal {
public:
    virtual void sound() {  // Virtual function
        cout << "Animal makes a sound" << endl;
    }
};

class Dog : public Animal {
public:
    void sound() override {  // Overriding the base class function
        cout << "Dog barks" << endl;
    }
};

int main() {
    Animal* animal = new Dog();
    animal->sound();  // Output: Dog barks (determined at runtime)
}

********************************************************

A pure virtual function in C++ is a function that has no implementation in the base class and must be overridden in any derived class. It makes the base class abstract, meaning you can't create objects of that class directly.

It is declared by assigning = 0 at the end of the function declaration.

class Animal {
public:
    virtual void sound() = 0;  // Pure virtual function
};

class Dog : public Animal {
public:
    void sound() override {
        cout << "Dog barks" << endl;
    }
};

int main() {
    // Animal a;  // Error: Cannot instantiate abstract class
    Dog d;
    d.sound();  // Output: Dog barks
}

********************************************************

An abstract class in C++ is a class that cannot be instantiated (objects cannot be created from it). It is used as a base class for other classes and often contains pure virtual functions. An abstract class provides a common interface that derived classes must implement.

Key Points:
It can have both implemented methods and pure virtual methods.
It is used to define common behaviors but requires derived classes to provide specific implementations for certain methods.

class Animal {
public:
    virtual void sound() = 0;  // Pure virtual function

    void breathe() {  // Regular function
        cout << "Animal is breathing." << endl;
    }
};

class Dog : public Animal {
public:
    void sound() override {
        cout << "Dog barks" << endl;
    }
};

int main() {
    // Animal a;  // Error: Cannot instantiate abstract class
    Dog d;
    d.sound();  // Output: Dog barks
    d.breathe();  // Output: Animal is breathing
}

********************************************************

Namespaces in C++ are used to group related functions, classes, and variables together to avoid naming conflicts. It helps in organizing code and preventing name clashes, especially when different libraries are used in the same program.

#include <iostream>
using namespace std;

namespace Math {
    int add(int a, int b) {
        return a + b;
    }
}

namespace Physics {
    double velocity(double distance, double time) {
        return distance / time;
    }
}

int main() {
    cout << "Addition: " << Math::add(5, 3) << endl;  // Using Math namespace
    cout << "Velocity: " << Physics::velocity(100, 2) << endl;  // Using Physics namespace
}

Key Points:
Namespaces allow you to define functions or variables with the same name in different areas of code without causing conflicts.
You use :: (scope resolution operator) to access items inside a namespace.
using namespace std; is often used to avoid writing std:: before standard library functions and objects.

********************************************************

Access specifiers in C++ define the visibility or accessibility of class members (variables and methods). The three main types are:

public: Members are accessible from anywhere.
private: Members are accessible only within the class.
protected: Members are accessible within the class and by derived classes.

********************************************************

Overloading is when you define multiple functions with the same name but different parameters, while overriding is when a derived class provides its own implementation of a function already defined in the base class.

********************************************************

